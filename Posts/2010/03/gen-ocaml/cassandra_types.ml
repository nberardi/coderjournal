(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
module ConsistencyLevel = 
struct
  type t = 
    | ZERO
    | ONE
    | QUORUM
    | DCQUORUM
    | DCQUORUMSYNC
    | ALL
  let to_i = function
    | ZERO -> 0
    | ONE -> 1
    | QUORUM -> 2
    | DCQUORUM -> 3
    | DCQUORUMSYNC -> 4
    | ALL -> 5
  let of_i = function
    | 0 -> ZERO
    | 1 -> ONE
    | 2 -> QUORUM
    | 3 -> DCQUORUM
    | 4 -> DCQUORUMSYNC
    | 5 -> ALL
    | _ -> raise Thrift_error
end
class column =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "column.name") | Some _x0 -> _x0
  method set_name _x0 = _name <- Some _x0
  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "column.value") | Some _x0 -> _x0
  method set_value _x0 = _value <- Some _x0
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "column.timestamp") | Some _x0 -> _x0
  method set_timestamp _x0 = _timestamp <- Some _x0
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Column";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_column (iprot : Protocol.t) =
  let _str3 = new column in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t4,_id5) = iprot#readFieldBegin in
        if _t4 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id5 with 
          | 1 -> (if _t4 = Protocol.T_STRING then
              _str3#set_name iprot#readString
            else
              iprot#skip _t4)
          | 2 -> (if _t4 = Protocol.T_STRING then
              _str3#set_value iprot#readString
            else
              iprot#skip _t4)
          | 3 -> (if _t4 = Protocol.T_I64 then
              _str3#set_timestamp iprot#readI64
            else
              iprot#skip _t4)
          | _ -> iprot#skip _t4);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str3

class superColumn =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "superColumn.name") | Some _x7 -> _x7
  method set_name _x7 = _name <- Some _x7
  val mutable _columns : column list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "superColumn.columns") | Some _x7 -> _x7
  method set_columns _x7 = _columns <- Some _x7
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SuperColumn";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with None -> () | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter10 ->         _iter10#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_superColumn (iprot : Protocol.t) =
  let _str11 = new superColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t12,_id13) = iprot#readFieldBegin in
        if _t12 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id13 with 
          | 1 -> (if _t12 = Protocol.T_STRING then
              _str11#set_name iprot#readString
            else
              iprot#skip _t12)
          | 2 -> (if _t12 = Protocol.T_LIST then
              _str11#set_columns 
                (let (_etype17,_size14) = iprot#readListBegin in
                  let _con18 = (Array.to_list (Array.init _size14 (fun _ -> (read_column iprot)))) in
                    iprot#readListEnd; _con18)
            else
              iprot#skip _t12)
          | _ -> iprot#skip _t12);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str11

class columnOrSuperColumn =
object (self)
  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "columnOrSuperColumn.column") | Some _x20 -> _x20
  method set_column _x20 = _column <- Some _x20
  val mutable _super_column : superColumn option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnOrSuperColumn.super_column") | Some _x20 -> _x20
  method set_super_column _x20 = _super_column <- Some _x20
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnOrSuperColumn";
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnOrSuperColumn (iprot : Protocol.t) =
  let _str23 = new columnOrSuperColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t24,_id25) = iprot#readFieldBegin in
        if _t24 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id25 with 
          | 1 -> (if _t24 = Protocol.T_STRUCT then
              _str23#set_column (read_column iprot)
            else
              iprot#skip _t24)
          | 2 -> (if _t24 = Protocol.T_STRUCT then
              _str23#set_super_column (read_superColumn iprot)
            else
              iprot#skip _t24)
          | _ -> iprot#skip _t24);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str23

class columnParent =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "columnParent.column_family") | Some _x27 -> _x27
  method set_column_family _x27 = _column_family <- Some _x27
  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnParent.super_column") | Some _x27 -> _x27
  method set_super_column _x27 = _super_column <- Some _x27
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnParent";
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnParent (iprot : Protocol.t) =
  let _str30 = new columnParent in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t31,_id32) = iprot#readFieldBegin in
        if _t31 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id32 with 
          | 3 -> (if _t31 = Protocol.T_STRING then
              _str30#set_column_family iprot#readString
            else
              iprot#skip _t31)
          | 4 -> (if _t31 = Protocol.T_STRING then
              _str30#set_super_column iprot#readString
            else
              iprot#skip _t31)
          | _ -> iprot#skip _t31);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str30

class columnPath =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "columnPath.column_family") | Some _x34 -> _x34
  method set_column_family _x34 = _column_family <- Some _x34
  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnPath.super_column") | Some _x34 -> _x34
  method set_super_column _x34 = _super_column <- Some _x34
  val mutable _column : string option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "columnPath.column") | Some _x34 -> _x34
  method set_column _x34 = _column <- Some _x34
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnPath";
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnPath (iprot : Protocol.t) =
  let _str37 = new columnPath in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t38,_id39) = iprot#readFieldBegin in
        if _t38 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id39 with 
          | 3 -> (if _t38 = Protocol.T_STRING then
              _str37#set_column_family iprot#readString
            else
              iprot#skip _t38)
          | 4 -> (if _t38 = Protocol.T_STRING then
              _str37#set_super_column iprot#readString
            else
              iprot#skip _t38)
          | 5 -> (if _t38 = Protocol.T_STRING then
              _str37#set_column iprot#readString
            else
              iprot#skip _t38)
          | _ -> iprot#skip _t38);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str37

class sliceRange =
object (self)
  val mutable _start : string option = None
  method get_start = _start
  method grab_start = match _start with None->raise (Field_empty "sliceRange.start") | Some _x41 -> _x41
  method set_start _x41 = _start <- Some _x41
  val mutable _finish : string option = None
  method get_finish = _finish
  method grab_finish = match _finish with None->raise (Field_empty "sliceRange.finish") | Some _x41 -> _x41
  method set_finish _x41 = _finish <- Some _x41
  val mutable _reversed : bool option = None
  method get_reversed = _reversed
  method grab_reversed = match _reversed with None->raise (Field_empty "sliceRange.reversed") | Some _x41 -> _x41
  method set_reversed _x41 = _reversed <- Some _x41
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "sliceRange.count") | Some _x41 -> _x41
  method set_count _x41 = _count <- Some _x41
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SliceRange";
    (match _start with None -> () | Some _v -> 
      oprot#writeFieldBegin("start",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _finish with None -> () | Some _v -> 
      oprot#writeFieldBegin("finish",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _reversed with None -> () | Some _v -> 
      oprot#writeFieldBegin("reversed",Protocol.T_BOOL,3);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_sliceRange (iprot : Protocol.t) =
  let _str44 = new sliceRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t45,_id46) = iprot#readFieldBegin in
        if _t45 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id46 with 
          | 1 -> (if _t45 = Protocol.T_STRING then
              _str44#set_start iprot#readString
            else
              iprot#skip _t45)
          | 2 -> (if _t45 = Protocol.T_STRING then
              _str44#set_finish iprot#readString
            else
              iprot#skip _t45)
          | 3 -> (if _t45 = Protocol.T_BOOL then
              _str44#set_reversed iprot#readBool
            else
              iprot#skip _t45)
          | 4 -> (if _t45 = Protocol.T_I32 then
              _str44#set_count iprot#readI32
            else
              iprot#skip _t45)
          | _ -> iprot#skip _t45);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str44

class slicePredicate =
object (self)
  val mutable _column_names : string list option = None
  method get_column_names = _column_names
  method grab_column_names = match _column_names with None->raise (Field_empty "slicePredicate.column_names") | Some _x48 -> _x48
  method set_column_names _x48 = _column_names <- Some _x48
  val mutable _slice_range : sliceRange option = None
  method get_slice_range = _slice_range
  method grab_slice_range = match _slice_range with None->raise (Field_empty "slicePredicate.slice_range") | Some _x48 -> _x48
  method set_slice_range _x48 = _slice_range <- Some _x48
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SlicePredicate";
    (match _column_names with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_names",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter51 ->         oprot#writeString(_iter51);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _slice_range with None -> () | Some _v -> 
      oprot#writeFieldBegin("slice_range",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_slicePredicate (iprot : Protocol.t) =
  let _str52 = new slicePredicate in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t53,_id54) = iprot#readFieldBegin in
        if _t53 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id54 with 
          | 1 -> (if _t53 = Protocol.T_LIST then
              _str52#set_column_names 
                (let (_etype58,_size55) = iprot#readListBegin in
                  let _con59 = (Array.to_list (Array.init _size55 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con59)
            else
              iprot#skip _t53)
          | 2 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_slice_range (read_sliceRange iprot)
            else
              iprot#skip _t53)
          | _ -> iprot#skip _t53);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str52

class keySlice =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "keySlice.key") | Some _x61 -> _x61
  method set_key _x61 = _key <- Some _x61
  val mutable _columns : columnOrSuperColumn list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "keySlice.columns") | Some _x61 -> _x61
  method set_columns _x61 = _columns <- Some _x61
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeySlice";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with None -> () | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter64 ->         _iter64#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keySlice (iprot : Protocol.t) =
  let _str65 = new keySlice in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t66,_id67) = iprot#readFieldBegin in
        if _t66 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id67 with 
          | 1 -> (if _t66 = Protocol.T_STRING then
              _str65#set_key iprot#readString
            else
              iprot#skip _t66)
          | 2 -> (if _t66 = Protocol.T_LIST then
              _str65#set_columns 
                (let (_etype71,_size68) = iprot#readListBegin in
                  let _con72 = (Array.to_list (Array.init _size68 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con72)
            else
              iprot#skip _t66)
          | _ -> iprot#skip _t66);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str65

class notFoundException =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "NotFoundException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception NotFoundException of notFoundException
let rec read_notFoundException (iprot : Protocol.t) =
  let _str77 = new notFoundException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t78,_id79) = iprot#readFieldBegin in
        if _t78 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id79 with 
          | _ -> iprot#skip _t78);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str77

class invalidRequestException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "invalidRequestException.why") | Some _x81 -> _x81
  method set_why _x81 = _why <- Some _x81
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "InvalidRequestException";
    (match _why with None -> () | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception InvalidRequestException of invalidRequestException
let rec read_invalidRequestException (iprot : Protocol.t) =
  let _str84 = new invalidRequestException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t85,_id86) = iprot#readFieldBegin in
        if _t85 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id86 with 
          | 1 -> (if _t85 = Protocol.T_STRING then
              _str84#set_why iprot#readString
            else
              iprot#skip _t85)
          | _ -> iprot#skip _t85);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str84

class unavailableException =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "UnavailableException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception UnavailableException of unavailableException
let rec read_unavailableException (iprot : Protocol.t) =
  let _str91 = new unavailableException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t92,_id93) = iprot#readFieldBegin in
        if _t92 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id93 with 
          | _ -> iprot#skip _t92);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str91

class timedOutException =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TimedOutException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception TimedOutException of timedOutException
let rec read_timedOutException (iprot : Protocol.t) =
  let _str98 = new timedOutException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t99,_id100) = iprot#readFieldBegin in
        if _t99 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id100 with 
          | _ -> iprot#skip _t99);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str98

