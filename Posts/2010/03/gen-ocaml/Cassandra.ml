(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class get_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_args.keyspace") | Some _x102 -> _x102
  method set_keyspace _x102 = _keyspace <- Some _x102
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_args.key") | Some _x102 -> _x102
  method set_key _x102 = _key <- Some _x102
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "get_args.column_path") | Some _x102 -> _x102
  method set_column_path _x102 = _column_path <- Some _x102
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_args.consistency_level") | Some _x102 -> _x102
  method set_consistency_level _x102 = _consistency_level <- Some _x102
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_args (iprot : Protocol.t) =
  let _str105 = new get_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t106,_id107) = iprot#readFieldBegin in
        if _t106 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id107 with 
          | 1 -> (if _t106 = Protocol.T_STRING then
              _str105#set_keyspace iprot#readString
            else
              iprot#skip _t106)
          | 2 -> (if _t106 = Protocol.T_STRING then
              _str105#set_key iprot#readString
            else
              iprot#skip _t106)
          | 3 -> (if _t106 = Protocol.T_STRUCT then
              _str105#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t106)
          | 4 -> (if _t106 = Protocol.T_I32 then
              _str105#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t106)
          | _ -> iprot#skip _t106);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str105

class get_result =
object (self)
  val mutable _success : columnOrSuperColumn option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_result.success") | Some _x108 -> _x108
  method set_success _x108 = _success <- Some _x108
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_result.ire") | Some _x108 -> _x108
  method set_ire _x108 = _ire <- Some _x108
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "get_result.nfe") | Some _x108 -> _x108
  method set_nfe _x108 = _nfe <- Some _x108
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_result.ue") | Some _x108 -> _x108
  method set_ue _x108 = _ue <- Some _x108
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_result.te") | Some _x108 -> _x108
  method set_te _x108 = _te <- Some _x108
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_result (iprot : Protocol.t) =
  let _str111 = new get_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t112,_id113) = iprot#readFieldBegin in
        if _t112 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id113 with 
          | 0 -> (if _t112 = Protocol.T_STRUCT then
              _str111#set_success (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t112)
          | 1 -> (if _t112 = Protocol.T_STRUCT then
              _str111#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t112)
          | 2 -> (if _t112 = Protocol.T_STRUCT then
              _str111#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t112)
          | 3 -> (if _t112 = Protocol.T_STRUCT then
              _str111#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t112)
          | 4 -> (if _t112 = Protocol.T_STRUCT then
              _str111#set_te (read_timedOutException iprot)
            else
              iprot#skip _t112)
          | _ -> iprot#skip _t112);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str111

class get_slice_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_slice_args.keyspace") | Some _x114 -> _x114
  method set_keyspace _x114 = _keyspace <- Some _x114
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x114 -> _x114
  method set_key _x114 = _key <- Some _x114
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_slice_args.column_parent") | Some _x114 -> _x114
  method set_column_parent _x114 = _column_parent <- Some _x114
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_slice_args.predicate") | Some _x114 -> _x114
  method set_predicate _x114 = _predicate <- Some _x114
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_slice_args.consistency_level") | Some _x114 -> _x114
  method set_consistency_level _x114 = _consistency_level <- Some _x114
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str117 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t118,_id119) = iprot#readFieldBegin in
        if _t118 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id119 with 
          | 1 -> (if _t118 = Protocol.T_STRING then
              _str117#set_keyspace iprot#readString
            else
              iprot#skip _t118)
          | 2 -> (if _t118 = Protocol.T_STRING then
              _str117#set_key iprot#readString
            else
              iprot#skip _t118)
          | 3 -> (if _t118 = Protocol.T_STRUCT then
              _str117#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t118)
          | 4 -> (if _t118 = Protocol.T_STRUCT then
              _str117#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t118)
          | 5 -> (if _t118 = Protocol.T_I32 then
              _str117#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t118)
          | _ -> iprot#skip _t118);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str117

class get_slice_result =
object (self)
  val mutable _success : columnOrSuperColumn list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x120 -> _x120
  method set_success _x120 = _success <- Some _x120
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_slice_result.ire") | Some _x120 -> _x120
  method set_ire _x120 = _ire <- Some _x120
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_slice_result.ue") | Some _x120 -> _x120
  method set_ue _x120 = _ue <- Some _x120
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_slice_result.te") | Some _x120 -> _x120
  method set_te _x120 = _te <- Some _x120
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter123 ->         _iter123#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str124 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t125,_id126) = iprot#readFieldBegin in
        if _t125 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id126 with 
          | 0 -> (if _t125 = Protocol.T_LIST then
              _str124#set_success 
                (let (_etype130,_size127) = iprot#readListBegin in
                  let _con131 = (Array.to_list (Array.init _size127 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con131)
            else
              iprot#skip _t125)
          | 1 -> (if _t125 = Protocol.T_STRUCT then
              _str124#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t125)
          | 2 -> (if _t125 = Protocol.T_STRUCT then
              _str124#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t125)
          | 3 -> (if _t125 = Protocol.T_STRUCT then
              _str124#set_te (read_timedOutException iprot)
            else
              iprot#skip _t125)
          | _ -> iprot#skip _t125);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str124

class multiget_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "multiget_args.keyspace") | Some _x132 -> _x132
  method set_keyspace _x132 = _keyspace <- Some _x132
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_args.keys") | Some _x132 -> _x132
  method set_keys _x132 = _keys <- Some _x132
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "multiget_args.column_path") | Some _x132 -> _x132
  method set_column_path _x132 = _column_path <- Some _x132
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_args.consistency_level") | Some _x132 -> _x132
  method set_consistency_level _x132 = _consistency_level <- Some _x132
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter135 ->         oprot#writeString(_iter135);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_args (iprot : Protocol.t) =
  let _str136 = new multiget_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t137,_id138) = iprot#readFieldBegin in
        if _t137 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id138 with 
          | 1 -> (if _t137 = Protocol.T_STRING then
              _str136#set_keyspace iprot#readString
            else
              iprot#skip _t137)
          | 2 -> (if _t137 = Protocol.T_LIST then
              _str136#set_keys 
                (let (_etype142,_size139) = iprot#readListBegin in
                  let _con143 = (Array.to_list (Array.init _size139 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con143)
            else
              iprot#skip _t137)
          | 3 -> (if _t137 = Protocol.T_STRUCT then
              _str136#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t137)
          | 4 -> (if _t137 = Protocol.T_I32 then
              _str136#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t137)
          | _ -> iprot#skip _t137);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str136

class multiget_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_result.success") | Some _x144 -> _x144
  method set_success _x144 = _success <- Some _x144
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_result.ire") | Some _x144 -> _x144
  method set_ire _x144 = _ire <- Some _x144
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_result.ue") | Some _x144 -> _x144
  method set_ue _x144 = _ue <- Some _x144
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_result.te") | Some _x144 -> _x144
  method set_te _x144 = _te <- Some _x144
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRUCT,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter147 -> fun _viter148 -> 
        oprot#writeString(_kiter147);
        _viter148#write(oprot);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_result (iprot : Protocol.t) =
  let _str149 = new multiget_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t150,_id151) = iprot#readFieldBegin in
        if _t150 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id151 with 
          | 0 -> (if _t150 = Protocol.T_MAP then
              _str149#set_success 
                (let (_ktype153,_vtype154,_size152) = iprot#readMapBegin in
                let _con156 = Hashtbl.create _size152 in
                  for i = 1 to _size152 do
                    let _k = iprot#readString in
                    let _v = (read_columnOrSuperColumn iprot) in
                      Hashtbl.add _con156 _k _v
                  done; iprot#readMapEnd; _con156)
            else
              iprot#skip _t150)
          | 1 -> (if _t150 = Protocol.T_STRUCT then
              _str149#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t150)
          | 2 -> (if _t150 = Protocol.T_STRUCT then
              _str149#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t150)
          | 3 -> (if _t150 = Protocol.T_STRUCT then
              _str149#set_te (read_timedOutException iprot)
            else
              iprot#skip _t150)
          | _ -> iprot#skip _t150);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str149

class multiget_slice_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "multiget_slice_args.keyspace") | Some _x157 -> _x157
  method set_keyspace _x157 = _keyspace <- Some _x157
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_slice_args.keys") | Some _x157 -> _x157
  method set_keys _x157 = _keys <- Some _x157
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_slice_args.column_parent") | Some _x157 -> _x157
  method set_column_parent _x157 = _column_parent <- Some _x157
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_slice_args.predicate") | Some _x157 -> _x157
  method set_predicate _x157 = _predicate <- Some _x157
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_slice_args.consistency_level") | Some _x157 -> _x157
  method set_consistency_level _x157 = _consistency_level <- Some _x157
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter160 ->         oprot#writeString(_iter160);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_args (iprot : Protocol.t) =
  let _str161 = new multiget_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t162,_id163) = iprot#readFieldBegin in
        if _t162 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id163 with 
          | 1 -> (if _t162 = Protocol.T_STRING then
              _str161#set_keyspace iprot#readString
            else
              iprot#skip _t162)
          | 2 -> (if _t162 = Protocol.T_LIST then
              _str161#set_keys 
                (let (_etype167,_size164) = iprot#readListBegin in
                  let _con168 = (Array.to_list (Array.init _size164 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con168)
            else
              iprot#skip _t162)
          | 3 -> (if _t162 = Protocol.T_STRUCT then
              _str161#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t162)
          | 4 -> (if _t162 = Protocol.T_STRUCT then
              _str161#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t162)
          | 5 -> (if _t162 = Protocol.T_I32 then
              _str161#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t162)
          | _ -> iprot#skip _t162);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str161

class multiget_slice_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_slice_result.success") | Some _x169 -> _x169
  method set_success _x169 = _success <- Some _x169
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_slice_result.ire") | Some _x169 -> _x169
  method set_ire _x169 = _ire <- Some _x169
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_slice_result.ue") | Some _x169 -> _x169
  method set_ue _x169 = _ue <- Some _x169
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_slice_result.te") | Some _x169 -> _x169
  method set_te _x169 = _te <- Some _x169
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter172 -> fun _viter173 -> 
        oprot#writeString(_kiter172);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter173);
        List.iter (fun _iter174 ->           _iter174#write(oprot);
        ) _viter173;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_result (iprot : Protocol.t) =
  let _str175 = new multiget_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t176,_id177) = iprot#readFieldBegin in
        if _t176 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id177 with 
          | 0 -> (if _t176 = Protocol.T_MAP then
              _str175#set_success 
                (let (_ktype179,_vtype180,_size178) = iprot#readMapBegin in
                let _con182 = Hashtbl.create _size178 in
                  for i = 1 to _size178 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype186,_size183) = iprot#readListBegin in
                        let _con187 = (Array.to_list (Array.init _size183 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con187) in
                      Hashtbl.add _con182 _k _v
                  done; iprot#readMapEnd; _con182)
            else
              iprot#skip _t176)
          | 1 -> (if _t176 = Protocol.T_STRUCT then
              _str175#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t176)
          | 2 -> (if _t176 = Protocol.T_STRUCT then
              _str175#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t176)
          | 3 -> (if _t176 = Protocol.T_STRUCT then
              _str175#set_te (read_timedOutException iprot)
            else
              iprot#skip _t176)
          | _ -> iprot#skip _t176);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str175

class get_count_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_count_args.keyspace") | Some _x188 -> _x188
  method set_keyspace _x188 = _keyspace <- Some _x188
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_count_args.key") | Some _x188 -> _x188
  method set_key _x188 = _key <- Some _x188
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_count_args.column_parent") | Some _x188 -> _x188
  method set_column_parent _x188 = _column_parent <- Some _x188
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_count_args.consistency_level") | Some _x188 -> _x188
  method set_consistency_level _x188 = _consistency_level <- Some _x188
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_args (iprot : Protocol.t) =
  let _str191 = new get_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t192,_id193) = iprot#readFieldBegin in
        if _t192 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id193 with 
          | 1 -> (if _t192 = Protocol.T_STRING then
              _str191#set_keyspace iprot#readString
            else
              iprot#skip _t192)
          | 2 -> (if _t192 = Protocol.T_STRING then
              _str191#set_key iprot#readString
            else
              iprot#skip _t192)
          | 3 -> (if _t192 = Protocol.T_STRUCT then
              _str191#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t192)
          | 4 -> (if _t192 = Protocol.T_I32 then
              _str191#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t192)
          | _ -> iprot#skip _t192);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str191

class get_count_result =
object (self)
  val mutable _success : int option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_count_result.success") | Some _x194 -> _x194
  method set_success _x194 = _success <- Some _x194
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_count_result.ire") | Some _x194 -> _x194
  method set_ire _x194 = _ire <- Some _x194
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_count_result.ue") | Some _x194 -> _x194
  method set_ue _x194 = _ue <- Some _x194
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_count_result.te") | Some _x194 -> _x194
  method set_te _x194 = _te <- Some _x194
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_result (iprot : Protocol.t) =
  let _str197 = new get_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t198,_id199) = iprot#readFieldBegin in
        if _t198 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id199 with 
          | 0 -> (if _t198 = Protocol.T_I32 then
              _str197#set_success iprot#readI32
            else
              iprot#skip _t198)
          | 1 -> (if _t198 = Protocol.T_STRUCT then
              _str197#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t198)
          | 2 -> (if _t198 = Protocol.T_STRUCT then
              _str197#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t198)
          | 3 -> (if _t198 = Protocol.T_STRUCT then
              _str197#set_te (read_timedOutException iprot)
            else
              iprot#skip _t198)
          | _ -> iprot#skip _t198);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str197

class get_key_range_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_key_range_args.keyspace") | Some _x200 -> _x200
  method set_keyspace _x200 = _keyspace <- Some _x200
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "get_key_range_args.column_family") | Some _x200 -> _x200
  method set_column_family _x200 = _column_family <- Some _x200
  val mutable _start : string option = None
  method get_start = _start
  method grab_start = match _start with None->raise (Field_empty "get_key_range_args.start") | Some _x200 -> _x200
  method set_start _x200 = _start <- Some _x200
  val mutable _finish : string option = None
  method get_finish = _finish
  method grab_finish = match _finish with None->raise (Field_empty "get_key_range_args.finish") | Some _x200 -> _x200
  method set_finish _x200 = _finish <- Some _x200
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "get_key_range_args.count") | Some _x200 -> _x200
  method set_count _x200 = _count <- Some _x200
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_key_range_args.consistency_level") | Some _x200 -> _x200
  method set_consistency_level _x200 = _consistency_level <- Some _x200
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_key_range_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start with None -> () | Some _v -> 
      oprot#writeFieldBegin("start",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _finish with None -> () | Some _v -> 
      oprot#writeFieldBegin("finish",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,6);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_key_range_args (iprot : Protocol.t) =
  let _str203 = new get_key_range_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t204,_id205) = iprot#readFieldBegin in
        if _t204 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id205 with 
          | 1 -> (if _t204 = Protocol.T_STRING then
              _str203#set_keyspace iprot#readString
            else
              iprot#skip _t204)
          | 2 -> (if _t204 = Protocol.T_STRING then
              _str203#set_column_family iprot#readString
            else
              iprot#skip _t204)
          | 3 -> (if _t204 = Protocol.T_STRING then
              _str203#set_start iprot#readString
            else
              iprot#skip _t204)
          | 4 -> (if _t204 = Protocol.T_STRING then
              _str203#set_finish iprot#readString
            else
              iprot#skip _t204)
          | 5 -> (if _t204 = Protocol.T_I32 then
              _str203#set_count iprot#readI32
            else
              iprot#skip _t204)
          | 6 -> (if _t204 = Protocol.T_I32 then
              _str203#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t204)
          | _ -> iprot#skip _t204);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str203

class get_key_range_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_key_range_result.success") | Some _x206 -> _x206
  method set_success _x206 = _success <- Some _x206
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_key_range_result.ire") | Some _x206 -> _x206
  method set_ire _x206 = _ire <- Some _x206
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_key_range_result.ue") | Some _x206 -> _x206
  method set_ue _x206 = _ue <- Some _x206
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_key_range_result.te") | Some _x206 -> _x206
  method set_te _x206 = _te <- Some _x206
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_key_range_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter209 ->         oprot#writeString(_iter209);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_key_range_result (iprot : Protocol.t) =
  let _str210 = new get_key_range_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t211,_id212) = iprot#readFieldBegin in
        if _t211 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id212 with 
          | 0 -> (if _t211 = Protocol.T_LIST then
              _str210#set_success 
                (let (_etype216,_size213) = iprot#readListBegin in
                  let _con217 = (Array.to_list (Array.init _size213 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con217)
            else
              iprot#skip _t211)
          | 1 -> (if _t211 = Protocol.T_STRUCT then
              _str210#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t211)
          | 2 -> (if _t211 = Protocol.T_STRUCT then
              _str210#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t211)
          | 3 -> (if _t211 = Protocol.T_STRUCT then
              _str210#set_te (read_timedOutException iprot)
            else
              iprot#skip _t211)
          | _ -> iprot#skip _t211);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str210

class get_range_slice_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "get_range_slice_args.keyspace") | Some _x218 -> _x218
  method set_keyspace _x218 = _keyspace <- Some _x218
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slice_args.column_parent") | Some _x218 -> _x218
  method set_column_parent _x218 = _column_parent <- Some _x218
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slice_args.predicate") | Some _x218 -> _x218
  method set_predicate _x218 = _predicate <- Some _x218
  val mutable _start_key : string option = None
  method get_start_key = _start_key
  method grab_start_key = match _start_key with None->raise (Field_empty "get_range_slice_args.start_key") | Some _x218 -> _x218
  method set_start_key _x218 = _start_key <- Some _x218
  val mutable _finish_key : string option = None
  method get_finish_key = _finish_key
  method grab_finish_key = match _finish_key with None->raise (Field_empty "get_range_slice_args.finish_key") | Some _x218 -> _x218
  method set_finish_key _x218 = _finish_key <- Some _x218
  val mutable _row_count : int option = None
  method get_row_count = _row_count
  method grab_row_count = match _row_count with None->raise (Field_empty "get_range_slice_args.row_count") | Some _x218 -> _x218
  method set_row_count _x218 = _row_count <- Some _x218
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_range_slice_args.consistency_level") | Some _x218 -> _x218
  method set_consistency_level _x218 = _consistency_level <- Some _x218
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slice_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _start_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_key",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _finish_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("finish_key",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _row_count with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_count",Protocol.T_I32,6);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,7);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slice_args (iprot : Protocol.t) =
  let _str221 = new get_range_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t222,_id223) = iprot#readFieldBegin in
        if _t222 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id223 with 
          | 1 -> (if _t222 = Protocol.T_STRING then
              _str221#set_keyspace iprot#readString
            else
              iprot#skip _t222)
          | 2 -> (if _t222 = Protocol.T_STRUCT then
              _str221#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t222)
          | 3 -> (if _t222 = Protocol.T_STRUCT then
              _str221#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t222)
          | 4 -> (if _t222 = Protocol.T_STRING then
              _str221#set_start_key iprot#readString
            else
              iprot#skip _t222)
          | 5 -> (if _t222 = Protocol.T_STRING then
              _str221#set_finish_key iprot#readString
            else
              iprot#skip _t222)
          | 6 -> (if _t222 = Protocol.T_I32 then
              _str221#set_row_count iprot#readI32
            else
              iprot#skip _t222)
          | 7 -> (if _t222 = Protocol.T_I32 then
              _str221#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t222)
          | _ -> iprot#skip _t222);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str221

class get_range_slice_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slice_result.success") | Some _x224 -> _x224
  method set_success _x224 = _success <- Some _x224
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slice_result.ire") | Some _x224 -> _x224
  method set_ire _x224 = _ire <- Some _x224
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slice_result.ue") | Some _x224 -> _x224
  method set_ue _x224 = _ue <- Some _x224
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slice_result.te") | Some _x224 -> _x224
  method set_te _x224 = _te <- Some _x224
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter227 ->         _iter227#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slice_result (iprot : Protocol.t) =
  let _str228 = new get_range_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t229,_id230) = iprot#readFieldBegin in
        if _t229 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id230 with 
          | 0 -> (if _t229 = Protocol.T_LIST then
              _str228#set_success 
                (let (_etype234,_size231) = iprot#readListBegin in
                  let _con235 = (Array.to_list (Array.init _size231 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con235)
            else
              iprot#skip _t229)
          | 1 -> (if _t229 = Protocol.T_STRUCT then
              _str228#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t229)
          | 2 -> (if _t229 = Protocol.T_STRUCT then
              _str228#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t229)
          | 3 -> (if _t229 = Protocol.T_STRUCT then
              _str228#set_te (read_timedOutException iprot)
            else
              iprot#skip _t229)
          | _ -> iprot#skip _t229);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str228

class insert_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "insert_args.keyspace") | Some _x236 -> _x236
  method set_keyspace _x236 = _keyspace <- Some _x236
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x236 -> _x236
  method set_key _x236 = _key <- Some _x236
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "insert_args.column_path") | Some _x236 -> _x236
  method set_column_path _x236 = _column_path <- Some _x236
  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "insert_args.value") | Some _x236 -> _x236
  method set_value _x236 = _value <- Some _x236
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "insert_args.timestamp") | Some _x236 -> _x236
  method set_timestamp _x236 = _timestamp <- Some _x236
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "insert_args.consistency_level") | Some _x236 -> _x236
  method set_consistency_level _x236 = _consistency_level <- Some _x236
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,5);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,6);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str239 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t240,_id241) = iprot#readFieldBegin in
        if _t240 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id241 with 
          | 1 -> (if _t240 = Protocol.T_STRING then
              _str239#set_keyspace iprot#readString
            else
              iprot#skip _t240)
          | 2 -> (if _t240 = Protocol.T_STRING then
              _str239#set_key iprot#readString
            else
              iprot#skip _t240)
          | 3 -> (if _t240 = Protocol.T_STRUCT then
              _str239#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t240)
          | 4 -> (if _t240 = Protocol.T_STRING then
              _str239#set_value iprot#readString
            else
              iprot#skip _t240)
          | 5 -> (if _t240 = Protocol.T_I64 then
              _str239#set_timestamp iprot#readI64
            else
              iprot#skip _t240)
          | 6 -> (if _t240 = Protocol.T_I32 then
              _str239#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t240)
          | _ -> iprot#skip _t240);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str239

class insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "insert_result.ire") | Some _x242 -> _x242
  method set_ire _x242 = _ire <- Some _x242
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "insert_result.ue") | Some _x242 -> _x242
  method set_ue _x242 = _ue <- Some _x242
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "insert_result.te") | Some _x242 -> _x242
  method set_te _x242 = _te <- Some _x242
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str245 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t246,_id247) = iprot#readFieldBegin in
        if _t246 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id247 with 
          | 1 -> (if _t246 = Protocol.T_STRUCT then
              _str245#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t246)
          | 2 -> (if _t246 = Protocol.T_STRUCT then
              _str245#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t246)
          | 3 -> (if _t246 = Protocol.T_STRUCT then
              _str245#set_te (read_timedOutException iprot)
            else
              iprot#skip _t246)
          | _ -> iprot#skip _t246);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str245

class batch_insert_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "batch_insert_args.keyspace") | Some _x248 -> _x248
  method set_keyspace _x248 = _keyspace <- Some _x248
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "batch_insert_args.key") | Some _x248 -> _x248
  method set_key _x248 = _key <- Some _x248
  val mutable _cfmap : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_cfmap = _cfmap
  method grab_cfmap = match _cfmap with None->raise (Field_empty "batch_insert_args.cfmap") | Some _x248 -> _x248
  method set_cfmap _x248 = _cfmap <- Some _x248
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "batch_insert_args.consistency_level") | Some _x248 -> _x248
  method set_consistency_level _x248 = _consistency_level <- Some _x248
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _cfmap with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfmap",Protocol.T_MAP,3);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter251 -> fun _viter252 -> 
        oprot#writeString(_kiter251);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter252);
        List.iter (fun _iter253 ->           _iter253#write(oprot);
        ) _viter252;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_args (iprot : Protocol.t) =
  let _str254 = new batch_insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t255,_id256) = iprot#readFieldBegin in
        if _t255 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id256 with 
          | 1 -> (if _t255 = Protocol.T_STRING then
              _str254#set_keyspace iprot#readString
            else
              iprot#skip _t255)
          | 2 -> (if _t255 = Protocol.T_STRING then
              _str254#set_key iprot#readString
            else
              iprot#skip _t255)
          | 3 -> (if _t255 = Protocol.T_MAP then
              _str254#set_cfmap 
                (let (_ktype258,_vtype259,_size257) = iprot#readMapBegin in
                let _con261 = Hashtbl.create _size257 in
                  for i = 1 to _size257 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype265,_size262) = iprot#readListBegin in
                        let _con266 = (Array.to_list (Array.init _size262 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con266) in
                      Hashtbl.add _con261 _k _v
                  done; iprot#readMapEnd; _con261)
            else
              iprot#skip _t255)
          | 4 -> (if _t255 = Protocol.T_I32 then
              _str254#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t255)
          | _ -> iprot#skip _t255);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str254

class batch_insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_insert_result.ire") | Some _x267 -> _x267
  method set_ire _x267 = _ire <- Some _x267
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_insert_result.ue") | Some _x267 -> _x267
  method set_ue _x267 = _ue <- Some _x267
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_insert_result.te") | Some _x267 -> _x267
  method set_te _x267 = _te <- Some _x267
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_result (iprot : Protocol.t) =
  let _str270 = new batch_insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t271,_id272) = iprot#readFieldBegin in
        if _t271 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id272 with 
          | 1 -> (if _t271 = Protocol.T_STRUCT then
              _str270#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t271)
          | 2 -> (if _t271 = Protocol.T_STRUCT then
              _str270#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t271)
          | 3 -> (if _t271 = Protocol.T_STRUCT then
              _str270#set_te (read_timedOutException iprot)
            else
              iprot#skip _t271)
          | _ -> iprot#skip _t271);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str270

class remove_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "remove_args.keyspace") | Some _x273 -> _x273
  method set_keyspace _x273 = _keyspace <- Some _x273
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x273 -> _x273
  method set_key _x273 = _key <- Some _x273
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "remove_args.column_path") | Some _x273 -> _x273
  method set_column_path _x273 = _column_path <- Some _x273
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "remove_args.timestamp") | Some _x273 -> _x273
  method set_timestamp _x273 = _timestamp <- Some _x273
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "remove_args.consistency_level") | Some _x273 -> _x273
  method set_consistency_level _x273 = _consistency_level <- Some _x273
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,4);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str276 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t277,_id278) = iprot#readFieldBegin in
        if _t277 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id278 with 
          | 1 -> (if _t277 = Protocol.T_STRING then
              _str276#set_keyspace iprot#readString
            else
              iprot#skip _t277)
          | 2 -> (if _t277 = Protocol.T_STRING then
              _str276#set_key iprot#readString
            else
              iprot#skip _t277)
          | 3 -> (if _t277 = Protocol.T_STRUCT then
              _str276#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t277)
          | 4 -> (if _t277 = Protocol.T_I64 then
              _str276#set_timestamp iprot#readI64
            else
              iprot#skip _t277)
          | 5 -> (if _t277 = Protocol.T_I32 then
              _str276#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t277)
          | _ -> iprot#skip _t277);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str276

class remove_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_result.ire") | Some _x279 -> _x279
  method set_ire _x279 = _ire <- Some _x279
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_result.ue") | Some _x279 -> _x279
  method set_ue _x279 = _ue <- Some _x279
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_result.te") | Some _x279 -> _x279
  method set_te _x279 = _te <- Some _x279
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str282 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t283,_id284) = iprot#readFieldBegin in
        if _t283 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id284 with 
          | 1 -> (if _t283 = Protocol.T_STRUCT then
              _str282#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t283)
          | 2 -> (if _t283 = Protocol.T_STRUCT then
              _str282#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t283)
          | 3 -> (if _t283 = Protocol.T_STRUCT then
              _str282#set_te (read_timedOutException iprot)
            else
              iprot#skip _t283)
          | _ -> iprot#skip _t283);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str282

class get_string_property_args =
object (self)
  val mutable _property : string option = None
  method get_property = _property
  method grab_property = match _property with None->raise (Field_empty "get_string_property_args.property") | Some _x285 -> _x285
  method set_property _x285 = _property <- Some _x285
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_property_args";
    (match _property with None -> () | Some _v -> 
      oprot#writeFieldBegin("property",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_property_args (iprot : Protocol.t) =
  let _str288 = new get_string_property_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t289,_id290) = iprot#readFieldBegin in
        if _t289 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id290 with 
          | 1 -> (if _t289 = Protocol.T_STRING then
              _str288#set_property iprot#readString
            else
              iprot#skip _t289)
          | _ -> iprot#skip _t289);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str288

class get_string_property_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_string_property_result.success") | Some _x291 -> _x291
  method set_success _x291 = _success <- Some _x291
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_property_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_property_result (iprot : Protocol.t) =
  let _str294 = new get_string_property_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t295,_id296) = iprot#readFieldBegin in
        if _t295 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id296 with 
          | 0 -> (if _t295 = Protocol.T_STRING then
              _str294#set_success iprot#readString
            else
              iprot#skip _t295)
          | _ -> iprot#skip _t295);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str294

class get_string_list_property_args =
object (self)
  val mutable _property : string option = None
  method get_property = _property
  method grab_property = match _property with None->raise (Field_empty "get_string_list_property_args.property") | Some _x297 -> _x297
  method set_property _x297 = _property <- Some _x297
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_list_property_args";
    (match _property with None -> () | Some _v -> 
      oprot#writeFieldBegin("property",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_list_property_args (iprot : Protocol.t) =
  let _str300 = new get_string_list_property_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t301,_id302) = iprot#readFieldBegin in
        if _t301 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id302 with 
          | 1 -> (if _t301 = Protocol.T_STRING then
              _str300#set_property iprot#readString
            else
              iprot#skip _t301)
          | _ -> iprot#skip _t301);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str300

class get_string_list_property_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_string_list_property_result.success") | Some _x303 -> _x303
  method set_success _x303 = _success <- Some _x303
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_string_list_property_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter306 ->         oprot#writeString(_iter306);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_string_list_property_result (iprot : Protocol.t) =
  let _str307 = new get_string_list_property_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t308,_id309) = iprot#readFieldBegin in
        if _t308 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id309 with 
          | 0 -> (if _t308 = Protocol.T_LIST then
              _str307#set_success 
                (let (_etype313,_size310) = iprot#readListBegin in
                  let _con314 = (Array.to_list (Array.init _size310 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con314)
            else
              iprot#skip _t308)
          | _ -> iprot#skip _t308);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str307

class describe_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_keyspace_args.keyspace") | Some _x315 -> _x315
  method set_keyspace _x315 = _keyspace <- Some _x315
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_args (iprot : Protocol.t) =
  let _str318 = new describe_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t319,_id320) = iprot#readFieldBegin in
        if _t319 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id320 with 
          | 1 -> (if _t319 = Protocol.T_STRING then
              _str318#set_keyspace iprot#readString
            else
              iprot#skip _t319)
          | _ -> iprot#skip _t319);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str318

class describe_keyspace_result =
object (self)
  val mutable _success : (string,(string,string) Hashtbl.t) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspace_result.success") | Some _x321 -> _x321
  method set_success _x321 = _success <- Some _x321
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "describe_keyspace_result.nfe") | Some _x321 -> _x321
  method set_nfe _x321 = _nfe <- Some _x321
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter324 -> fun _viter325 -> 
        oprot#writeString(_kiter324);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _viter325);
        Hashtbl.iter (fun _kiter326 -> fun _viter327 -> 
          oprot#writeString(_kiter326);
          oprot#writeString(_viter327);
        ) _viter325;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_result (iprot : Protocol.t) =
  let _str328 = new describe_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t329,_id330) = iprot#readFieldBegin in
        if _t329 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id330 with 
          | 0 -> (if _t329 = Protocol.T_MAP then
              _str328#set_success 
                (let (_ktype332,_vtype333,_size331) = iprot#readMapBegin in
                let _con335 = Hashtbl.create _size331 in
                  for i = 1 to _size331 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype337,_vtype338,_size336) = iprot#readMapBegin in
                      let _con340 = Hashtbl.create _size336 in
                        for i = 1 to _size336 do
                          let _k = iprot#readString in
                          let _v = iprot#readString in
                            Hashtbl.add _con340 _k _v
                        done; iprot#readMapEnd; _con340) in
                      Hashtbl.add _con335 _k _v
                  done; iprot#readMapEnd; _con335)
            else
              iprot#skip _t329)
          | 1 -> (if _t329 = Protocol.T_STRUCT then
              _str328#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t329)
          | _ -> iprot#skip _t329);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str328

class virtual iface =
object (self)
  method virtual get : string option -> string option -> columnPath option -> ConsistencyLevel.t option -> columnOrSuperColumn
  method virtual get_slice : string option -> string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> columnOrSuperColumn list
  method virtual multiget : string option -> string list option -> columnPath option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn) Hashtbl.t
  method virtual multiget_slice : string option -> string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn list) Hashtbl.t
  method virtual get_count : string option -> string option -> columnParent option -> ConsistencyLevel.t option -> int
  method virtual get_key_range : string option -> string option -> string option -> string option -> int option -> ConsistencyLevel.t option -> string list
  method virtual get_range_slice : string option -> columnParent option -> slicePredicate option -> string option -> string option -> int option -> ConsistencyLevel.t option -> keySlice list
  method virtual insert : string option -> string option -> columnPath option -> string option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual batch_insert : string option -> string option -> (string,columnOrSuperColumn list) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual remove : string option -> string option -> columnPath option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual get_string_property : string option -> string
  method virtual get_string_list_property : string option -> string list
  method virtual describe_keyspace : string option -> (string,(string,string) Hashtbl.t) Hashtbl.t
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method get keyspace key column_path consistency_level = 
    self#send_get keyspace key column_path consistency_level;
    self#recv_get
  method private send_get keyspace key column_path consistency_level = 
    oprot#writeMessageBegin ("get", Protocol.CALL, seqid);
    let args = new get_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get failed: unknown result")))
  method get_slice keyspace key column_parent predicate consistency_level = 
    self#send_get_slice keyspace key column_parent predicate consistency_level;
    self#recv_get_slice
  method private send_get_slice keyspace key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method multiget keyspace keys column_path consistency_level = 
    self#send_multiget keyspace keys column_path consistency_level;
    self#recv_multiget
  method private send_multiget keyspace keys column_path consistency_level = 
    oprot#writeMessageBegin ("multiget", Protocol.CALL, seqid);
    let args = new multiget_args in
      args#set_keyspace keyspace;
      args#set_keys keys;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget failed: unknown result")))
  method multiget_slice keyspace keys column_parent predicate consistency_level = 
    self#send_multiget_slice keyspace keys column_parent predicate consistency_level;
    self#recv_multiget_slice
  method private send_multiget_slice keyspace keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_slice", Protocol.CALL, seqid);
    let args = new multiget_slice_args in
      args#set_keyspace keyspace;
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_slice failed: unknown result")))
  method get_count keyspace key column_parent consistency_level = 
    self#send_get_count keyspace key column_parent consistency_level;
    self#recv_get_count
  method private send_get_count keyspace key column_parent consistency_level = 
    oprot#writeMessageBegin ("get_count", Protocol.CALL, seqid);
    let args = new get_count_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_count failed: unknown result")))
  method get_key_range keyspace column_family start finish count consistency_level = 
    self#send_get_key_range keyspace column_family start finish count consistency_level;
    self#recv_get_key_range
  method private send_get_key_range keyspace column_family start finish count consistency_level = 
    oprot#writeMessageBegin ("get_key_range", Protocol.CALL, seqid);
    let args = new get_key_range_args in
      args#set_keyspace keyspace;
      args#set_column_family column_family;
      args#set_start start;
      args#set_finish finish;
      args#set_count count;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_key_range  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_key_range_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_key_range failed: unknown result")))
  method get_range_slice keyspace column_parent predicate start_key finish_key row_count consistency_level = 
    self#send_get_range_slice keyspace column_parent predicate start_key finish_key row_count consistency_level;
    self#recv_get_range_slice
  method private send_get_range_slice keyspace column_parent predicate start_key finish_key row_count consistency_level = 
    oprot#writeMessageBegin ("get_range_slice", Protocol.CALL, seqid);
    let args = new get_range_slice_args in
      args#set_keyspace keyspace;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_start_key start_key;
      args#set_finish_key finish_key;
      args#set_row_count row_count;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slice failed: unknown result")))
  method insert keyspace key column_path value timestamp consistency_level = 
    self#send_insert keyspace key column_path value timestamp consistency_level;
    self#recv_insert
  method private send_insert keyspace key column_path value timestamp consistency_level = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_path column_path;
      args#set_value value;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_insert keyspace key cfmap consistency_level = 
    self#send_batch_insert keyspace key cfmap consistency_level;
    self#recv_batch_insert
  method private send_batch_insert keyspace key cfmap consistency_level = 
    oprot#writeMessageBegin ("batch_insert", Protocol.CALL, seqid);
    let args = new batch_insert_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_cfmap cfmap;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove keyspace key column_path timestamp consistency_level = 
    self#send_remove keyspace key column_path timestamp consistency_level;
    self#recv_remove
  method private send_remove keyspace key column_path timestamp consistency_level = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_keyspace keyspace;
      args#set_key key;
      args#set_column_path column_path;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method get_string_property property = 
    self#send_get_string_property property;
    self#recv_get_string_property
  method private send_get_string_property property = 
    oprot#writeMessageBegin ("get_string_property", Protocol.CALL, seqid);
    let args = new get_string_property_args in
      args#set_property property;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_string_property  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_string_property_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_string_property failed: unknown result")))
  method get_string_list_property property = 
    self#send_get_string_list_property property;
    self#recv_get_string_list_property
  method private send_get_string_list_property property = 
    oprot#writeMessageBegin ("get_string_list_property", Protocol.CALL, seqid);
    let args = new get_string_list_property_args in
      args#set_property property;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_string_list_property  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_string_list_property_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_string_list_property failed: unknown result")))
  method describe_keyspace keyspace = 
    self#send_describe_keyspace keyspace;
    self#recv_describe_keyspace
  method private send_describe_keyspace keyspace = 
    oprot#writeMessageBegin ("describe_keyspace", Protocol.CALL, seqid);
    let args = new describe_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspace failed: unknown result")))
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 13
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_get (seqid, iprot, oprot) =
    let args = read_get_args iprot in
      iprot#readMessageEnd;
      let result = new get_result in
        (try
          result#set_success (handler#get args#get_keyspace args#get_key args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        (try
          result#set_success (handler#get_slice args#get_keyspace args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget (seqid, iprot, oprot) =
    let args = read_multiget_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_result in
        (try
          result#set_success (handler#multiget args#get_keyspace args#get_keys args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_slice (seqid, iprot, oprot) =
    let args = read_multiget_slice_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_slice_result in
        (try
          result#set_success (handler#multiget_slice args#get_keyspace args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_count (seqid, iprot, oprot) =
    let args = read_get_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_count_result in
        (try
          result#set_success (handler#get_count args#get_keyspace args#get_key args#get_column_parent args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_key_range (seqid, iprot, oprot) =
    let args = read_get_key_range_args iprot in
      iprot#readMessageEnd;
      let result = new get_key_range_result in
        (try
          result#set_success (handler#get_key_range args#get_keyspace args#get_column_family args#get_start args#get_finish args#get_count args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_key_range", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slice (seqid, iprot, oprot) =
    let args = read_get_range_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slice_result in
        (try
          result#set_success (handler#get_range_slice args#get_keyspace args#get_column_parent args#get_predicate args#get_start_key args#get_finish_key args#get_row_count args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      let result = new insert_result in
        (try
          (handler#insert args#get_keyspace args#get_key args#get_column_path args#get_value args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_insert (seqid, iprot, oprot) =
    let args = read_batch_insert_args iprot in
      iprot#readMessageEnd;
      let result = new batch_insert_result in
        (try
          (handler#batch_insert args#get_keyspace args#get_key args#get_cfmap args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      let result = new remove_result in
        (try
          (handler#remove args#get_keyspace args#get_key args#get_column_path args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_string_property (seqid, iprot, oprot) =
    let args = read_get_string_property_args iprot in
      iprot#readMessageEnd;
      let result = new get_string_property_result in
        result#set_success (handler#get_string_property args#get_property);
        oprot#writeMessageBegin ("get_string_property", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_string_list_property (seqid, iprot, oprot) =
    let args = read_get_string_list_property_args iprot in
      iprot#readMessageEnd;
      let result = new get_string_list_property_result in
        result#set_success (handler#get_string_list_property args#get_property);
        oprot#writeMessageBegin ("get_string_list_property", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspace (seqid, iprot, oprot) =
    let args = read_describe_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspace_result in
        (try
          result#set_success (handler#describe_keyspace args#get_keyspace);
        with
          | NotFoundException nfe -> 
              result#set_nfe nfe
        );
        oprot#writeMessageBegin ("describe_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "get" self#process_get;
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "multiget" self#process_multiget;
    Hashtbl.add processMap "multiget_slice" self#process_multiget_slice;
    Hashtbl.add processMap "get_count" self#process_get_count;
    Hashtbl.add processMap "get_key_range" self#process_get_key_range;
    Hashtbl.add processMap "get_range_slice" self#process_get_range_slice;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "batch_insert" self#process_batch_insert;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "get_string_property" self#process_get_string_property;
    Hashtbl.add processMap "get_string_list_property" self#process_get_string_list_property;
    Hashtbl.add processMap "describe_keyspace" self#process_describe_keyspace;
end

